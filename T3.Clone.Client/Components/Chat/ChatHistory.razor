@using T3.Clone.Client.Caches
@inject ThreadSyncService ThreadSyncService
@inject NavigationManager NavigationManager
@implements IDisposable

<div class="chat-history-container">
    <div class="new-chat-section">
        <NewChatButton OnClick="StartNewChat" />
    </div>
    
    <div class="threads-scroll-section">
        <ThreadNavigation Threads="threads" 
                          CurrentThreadId="currentThreadId" 
                          OnThreadSelected="OnThreadSelected"
                          OnDeleteThread="DeleteThreadAsync" />
    </div>
</div>

@code {
    private List<ThreadCache> threads = new List<ThreadCache>();
    private int? currentThreadId;

    protected override async Task OnInitializedAsync()
    {
        threads = await ThreadSyncService.GetThreads((caches) =>
        {
            Console.WriteLine("Received threads from ThreadSyncService");
            threads = caches;
            StateHasChanged();
        });
        
        ThreadSyncService.ThreadsUpdated += (caches) =>
        {
            Console.WriteLine("Updating threads from ThreadSyncService");
            threads = caches;
            StateHasChanged();
        };

        // Listen to navigation changes
        NavigationManager.LocationChanged += OnLocationChanged;
        
        // Set initial thread ID
        UpdateCurrentThreadId();
    }

    private void OnLocationChanged(object? sender, Microsoft.AspNetCore.Components.Routing.LocationChangedEventArgs e)
    {
        UpdateCurrentThreadId();
        StateHasChanged();
    }

    private void UpdateCurrentThreadId()
    {
        var uri = NavigationManager.Uri;
        var segments = uri.Split('/');
        
        if (segments.Length >= 2 && segments[^2] == "chat" && int.TryParse(segments[^1], out int threadId))
        {
            currentThreadId = threadId;
        }
        else
        {
            currentThreadId = null;
        }
    }

    private void StartNewChat()
    {
        NavigationManager.NavigateTo("/");
    }

    private void OnThreadSelected(int threadId)
    {
        // Navigation is handled by the ThreadNavigation component
    }

    public void Dispose()
    {
        ThreadSyncService.ThreadsUpdated -= (caches) =>
        {
            threads = caches;
            StateHasChanged();
        };
        
        NavigationManager.LocationChanged -= OnLocationChanged;
    }
    
    // TODO instead of just delete, put a modal with "Are you sure?"
    private async Task DeleteThreadAsync(int threadId)
    {
        // Remove from cache and update UI
        threads = threads.Where(t => t.Thread.Id != threadId).ToList();
        StateHasChanged();
        
        // Delete from backend
        await ThreadSyncService.DeleteThread(threadId);
    }
}