@using T3.Clone.Client.Caches
@inject NavigationManager NavigationManager
@inject ThreadSyncService ThreadSyncService

<div class="thread-navigation">
    @foreach(var cache in Threads.Where(x => !x.Thread.Deleted))
    {
        <a href="@($"/chat/{cache.Thread.Id}")"
           class="thread-nav-link @(IsActive(cache.Thread.Id) ? "active" : "")"
           @onclick="@(() => OnThreadSelected.InvokeAsync(cache.Thread.Id))">
            <div class="thread-content">
                <div class="thread-icon">
                    <svg viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
                    </svg>
                </div>
                <span class="thread-title">@cache.Thread.Title</span>
            </div>
        </a>
    }
</div>


@code {
    [Parameter] public List<ThreadCache> Threads { get; set; } = new();
    [Parameter] public EventCallback<int> OnThreadSelected { get; set; }
    [Parameter] public int? CurrentThreadId { get; set; }

    private bool IsActive(int threadId)
    {
        return CurrentThreadId == threadId;
    }
    
    
    private async Task EditThreadName(ThreadCache cache, string name)
    {
        // Remove from cache and update UI
        cache.Thread.Title = name;
        StateHasChanged();
        
        // Delete from backend
        await ThreadSyncService.UpdateThread(cache);
    }
    
    private async Task DeleteThreadAsync(ThreadCache cache)
    {
        // Remove from cache and update UI
        cache.Thread.Deleted = true;
        StateHasChanged();
        
        // Delete from backend
        await ThreadSyncService.UpdateThread(cache);
    }
} 